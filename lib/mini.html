<div class='mini'>
  <div class='status'>
    <span class='focusStatus {{focusStatus}}'></span>
    <span class='progress'>{{results.length}}/{{totalCount}}</span>
    <span class='failureGroups'>
      {{#each failureGroups as group}}
        <span on:click='set({selectedGroup: group})' title={{group.key}}></span>
      {{/each}}
    </span>
    <button on:click='run()'>^</button>
    <button on:click='fastChange()'>&gt;</button>
    <button on:click='run({force: true}, event)'>R</button>
    <button on:click='run({fullRun: true}, event)'>F</button>
  </div>

  {{#if selectedGroup}}
  <div class='groupDetails'>
    <div>{{selectedGroup.key}}</div>
    {{#each selectedGroup as result}}
      <a href={{testUrl(result)}} on:click='fastChange(event)' class='fail'>{{result.fullName}}</a>
    {{/each}}
  </div>
  {{/if}}
</div>

<style>
  .mini {
    all: initial;
    position: fixed;
    top: 0; width: 300px; left: 50%;
    margin-left: -150px;
    padding: 10px 5px;
    border: 1px solid #ddd;
    background: #fff;
    font-size: 10px;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
  }
  .mini * { all: unset; }

  .status { display: flex; }
  .status > * { margin: 0 3px; }
  .failureGroups { flex: 1; }

  .focusStatus {
    flex: 0 0 10px; height: 10px;
    border-radius: 50%;
  }
  .focusStatus.none { display: none; }
  .focusStatus.running { border: 1px solid #ddd; }
  .focusStatus.passed { background-color: green; }

  .failureGroups > span {
    display: inline-block;
    width: 1em; height: 1em;
    border-radius: 50%;
    background-color: maroon;
    margin-right: 3px;
    cursor: pointer;
  }

  .groupDetails > a {
    display: block;
    margin-top: 5px;
    color: maroon;
    font-size: 10px;
  }
</style>

<script>
  function oncreate() {
    Latte.setup('debug')
    Latte.onTest = onTest.bind(this)

    this.ws = new WebSocket(`ws://${location.host}/head`)
    this.ws.onmessage = (msg) => {
      let data = JSON.parse(msg.data)

      if (data.runId && data.runId != this.get('runId'))
        this.set({results: [], runId: data.runId, totalCount: data.totalCount})

      if (data.results)
        this.set({results: this.get('results').concat(data.results)})

      if (data.codeHash && ZenWebpackClient.needsUpdate(data.codeHash))
        this.updateCode(data.codeHash)
    }
    this.ws.onopen = this.run.bind(this, false)
    window.onpopstate = this.run.bind(this, false)
  }

  function run(opts, event) {
    let params = new URLSearchParams(location.search)
    let grep = params.get('grep') && new RegExp(params.get('grep'), 'i')
    let focus = params.get('focus') && new RegExp(params.get('focus'), 'i')
    let tests = Latte.flatten().filter(t => !grep || grep.test(t.fullName))
    let reload = event && event.shiftKey
    let singleWorker = event && event.altKey

    this.set({focusStatus: focus ? 'running' : 'none', selectedGroup: null})

    // tell workers what to do
    let testNames = tests.map(t => t.fullName)
    let request = Object.assign({grep: params.get('grep'), reload, testNames, singleWorker}, opts)
    this.ws.send(JSON.stringify(request))

    if (focus) { // if we're focused, run those tests
      tests = tests.filter(t => focus.test(t.fullName))
      Latte.run(tests).then(() => this.set({focusStatus: 'passed'}))
    }
  }

  async function updateCode(hash) {
    this.mostRecentHash = hash
    if (this.updating) return
    this.updating = true

    await Latte.abort()
    while(ZenWebpackClient.needsUpdate(this.mostRecentHash))
      await ZenWebpackClient.update()
    this.updating = false

    this.run()
  }

  // handle link clicks without reloading
  function fastChange(event) {
    let url = testUrl(this.get('failureGroups')[0][0])
    if (event) {
      url = event.target.getAttribute('href')
      event.preventDefault()
    }
    history.pushState({}, 'Zen', url)
    this.run()
  }

  function testUrl(result) {
    let sp = new URLSearchParams(location.search)
    sp.set('focus', result.fullName)
    return '?' + sp.toString()
  }

  function onTest(test, error) {
    if (error)
      this.set({focusFailure: error})
  }

  function failureGroups(results) {
    let groups = {}
    results.forEach(t => {
      if (!t.error) return
      if (!t.error.stack) t.error.stack = 'unknown \n unknown'
      let key = t.error.message + t.error.stack.split('\n')[1]
      groups[key] = groups[key] || []
      groups[key].key = key
      groups[key].push(t)
    })
    return Object.values(groups)
  }

  export default {
    oncreate,
    data: () => ({results: [], totalCount: 0, focusStatus: 'none'}),
    computed: {failureGroups: results => failureGroups(results)},
    helpers: {testUrl},
    methods: {fastChange, run, updateCode}
  }
</script>
