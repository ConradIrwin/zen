<div class='mini'>
  <div class='status'>
    <span class='focusStatus'>f</span>
    <span class='progress'>{{results.length}}/{{totalCount}}</span>
    <span class='failureGroups'>x</span>
    <span class='failCount'>0</span>
    <button on:click='fastChange()'>&gt;</button>
    <button on:click='run(true)'>R</button>
  </div>

  {{#if selectedGroup}}
  <div class='groupDetails'>
    {{#each fails as f}}
      <a href={{testUrl(f)}} on:click='fastChange(event)' class='fail'>{{f.fullName}}</a>
    {{/each}}
  </div>
  {{/if}}
</div>

<style>
  .mini {
    position: fixed;
    top: 0; width: 300px; left: 50%;
    margin-left: -150px;
    padding: 10px;
    border: 1px solid #ddd;
    font-size: 10px;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
  }

  .status { display: flex; }
  .status > * { flex: 0; }
  .failureGroups { flex: 1; }

  .fail {
    color: maroon;
    font: 10px;
  }
</style>

<script>
  function oncreate() {
    Latte.mode = 'debug'
    Latte.onTest = onTest.bind(this)
    Latte.onTimeout = onTimeout.bind(this)

    this.ws = new WebSocket(`ws://${location.host}/head`)
    this.ws.onmessage = (msg) => {
      let data = JSON.parse(msg.data)

      if (data.results)
        this.set({results: this.get('results').concat(data.results)})

      if (data.codeHash && ZenWebpackClient.needsUpdate(data.codeHash))
        this.updateCode(data.codeHash)
    }
    this.ws.onopen = this.run.bind(this, false)
    window.onpopstate = this.run.bind(this, false)
  }

  function run(force) {
    let params = new URLSearchParams(location.search)
    let grep = params.get('grep') && new RegExp(params.get('grep'), 'i')
    let focus = params.get('focus') && new RegExp(params.get('focus'), 'i')
    let tests = Latte.flatten().filter(t => !grep || grep.test(t.fullName))

    this.testsByName = {}
    tests.forEach(t => this.testsByName[t.fullName] = t)

    this.set({results: [], totalCount: tests.length, focusFailure: null})

    // tell workers what to do
    this.ws.send(JSON.stringify({grep: params.get('grep') || '', force}))

    if (focus) { // if we're focused, run those tests
      let focused = tests.filter(t => focus.test(t.fullName))
      Latte.run({mode: 'debug', tests, onTimeout: onTimeout.bind(this), onTest: onTest.bind(this)})
    }
  }

  async function updateCode(hash) {
    this.mostRecentHash = hash
    if (this.updating) return
    this.updating = true

    await Latte.abort()
    while(ZenWebpackClient.needsUpdate(this.mostRecentHash))
      await ZenWebpackClient.update()
    this.updating = false

    this.run()
  }

  // handle link clicks without reloading
  function fastChange(event) {
    // TODO: if no event
    history.pushState({}, 'Zen', event.target.getAttribute('href'))
    event.preventDefault()
    this.run()
  }

  function testUrl(result) {
    let sp = new URLSearchParams(location.search)
    sp.set('focus', result.fullName)
    return '?' + sp.toString()
  }

  function onTimeout(err) {
    console.error('timeout', err)
    this.set({focusFailure: `Timeout (see console)`})
  }

  function onTest(test, error) {
    if (error)
      this.set({focusFailure: error})
  }

  function failureGroups(results) {
    let groups = {}
    results.forEach(t => {
      if (!t.error) return
      debugger
      1
    })
    return Object.values(groups)
  }

  export default {
    oncreate,
    data: () => ({results: [], totalCount: 0, focusFailure: null}),
    computed: {failureGroups: results => failureGroups(results)},
    helpers: {testUrl},
    methods: {fastChange, run, updateCode}
  }
</script>
