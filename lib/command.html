<div class='ZenCommand'>
  <input bind:value='input' ref:prompt on:blur='store.closeCommand()' on:keydown='onKeyDown(event)' on:input='setSelected(0)' />
  <div ref:list class='suggestions'>
    {#each suggestions as suggestion, index}
      <div class="{index == selectedIndex ? 'selected' : ''}" title={altText(suggestion)} on:mousedown='takeAction(index)'>
        {@html icon(suggestion)}
        <span class='title'>{suggestion.title}</span>
        {#if suggestion.key}
          <div class='keys'>
            {#each suggestion.key.split(' ') as k}
              <span>{k}</span>
            {/each}
          </div>
        {/if}
      </div>
    {/each}
  </div>
</div>

<style>
  .ZenCommand {
    all: unset;
    line-height: 1.5em;

    width: 80%;
    max-width: 500px;
    position: absolute;
    top: 200px;
    left: 50%;
    margin-right: -50%;
    transform: translate(-50%, 0);

    background: #212121;
    color: #ddd;
    font-size: 12px;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
  }

  input {
    display: inline-block;
    width: 100%;
    border: none;
    background: none;
    padding: 14px 30px 10px 50px;
    border-bottom: 1px solid #313131;
    color: inherit;
    font-size: inherit;
  }

  .suggestions {
    display: block;
    height: 400px;
    overflow: scroll;
  }

  .suggestions > div {
    display: flex;
    align-items: center;
    padding: 5px 14px;
  }

  .ZenCommand :global(svg) {
    fill: #aaa;
    border: 1px solid #ddd;
    border-radius: 50%;
    padding: 5px;
    height: 24px;
    flex: 0 0 24px;
    margin-right: 14px;
  }

  .title { flex: 1; }

  .selected {
    background: #313131;
  }

  .keys {
    flex: 0 0;
    white-space: nowrap;
  }
  .keys > span {
    font-size: 10px;
    display: inline-block;
    padding: 1px 4px;
    border: 1px solid #aaa;
    border-radius: 1px;
    margin-left: 3px;
  }
</style>

<script>
  function oncreate() {
    let queue = [Latte.root], step
    let nodes = Array.from(Zen.commands)
    while (step = queue.pop()) {
      if (step.fullName)
        nodes.push({type: 'describe', title: step.fullName, depth: step.depth})
      step.tests.forEach(t => nodes.push({type: 'test', title: t.fullName, describe: step.fullName}))
      queue = queue.concat(step.children)
    }

    this.set({nodes})
    this.refs.prompt.focus()
  }

  function onKeyDown(event) {
    event.stopPropagation()
    if (event.keyCode == 38) // up
      this.setSelected(this.get().selectedIndex - 1)
    else if (event.keyCode == 40) // down
      this.setSelected(this.get().selectedIndex + 1)
    else if (event.keyCode == 27) // escape
      store.closeCommand()
    else if (event.keyCode == 13) // enter
      this.takeAction(this.get().selectedIndex)
    else return
    event.preventDefault()

  }

  function takeAction(idx) {
    let sugg = this.get().suggestions[idx]
    if (sugg.action) sugg.action()
    else if (sugg.type == 'describe') this.store.run({grep: sugg.title, focus: null})
    else if (sugg.type == 'test') this.store.run({grep: sugg.describe, focus: sugg.title})
    store.closeCommand()
  }

  function setSelected(idx) {
    idx = Math.max(0, idx)
    idx = Math.min(this.get().suggestions.length - 1, idx)
    this.set({selectedIndex: idx})

    let el = this.refs.list.children[idx]
    // TODO scroll into view
  }

  function icon(node) {
    if (node.icon) return node.icon
    if (node.type == 'describe') return `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="22" height="28" viewBox="0 0 22 28"><path d="M21.922 4.609c0.156 0.375 0.078 0.812-0.219 1.094l-7.703 7.703v11.594c0 0.406-0.25 0.766-0.609 0.922-0.125 0.047-0.266 0.078-0.391 0.078-0.266 0-0.516-0.094-0.703-0.297l-4-4c-0.187-0.187-0.297-0.438-0.297-0.703v-7.594l-7.703-7.703c-0.297-0.281-0.375-0.719-0.219-1.094 0.156-0.359 0.516-0.609 0.922-0.609h20c0.406 0 0.766 0.25 0.922 0.609z"></path></svg>`
    if (node.type == 'test') return `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path d="M0 2h32v4h-32zM0 8h20v4h-20zM0 20h20v4h-20zM0 14h32v4h-32zM0 26h32v4h-32z"></path></svg>`
  }

  function altText(node) {
    if (node.altText) return node.altText
    if (node.type == 'describe') return 'Only run tests in this suite'
    if (node.type == 'test') return 'Run this test in this tab'
  }

  function suggestions(input='', nodes=[]) {
    let priorityMap = {command: 0, describe: 1, test: 2}

    let sorted = nodes.map((node, idx) => {
      let score = input ? commandScore(node.title, input, node.title.toLowerCase(), input.toLowerCase(), 0, 0) : 0
      let priority = priorityMap[node.type]
      return {node, score, idx, priority}
    }).sort((a, b) => {
      if (a.score !== b.score) return b.score - a.score
      if (a.priority !== b.priority) return a.priority - b.priority
      if (a.node.depth && b.node.depth && a.node.depth !== b.node.depth) return a.node.depth - b.node.depth
      return a.idx - b.idx
    })

    return sorted.slice(0, 50).map(tuple => tuple.node)
  }

  let SCORE_CONTINUE_MATCH = 1,
    SCORE_SPACE_WORD_JUMP = 0.9,
    SCORE_NON_SPACE_WORD_JUMP = 0.8,
    SCORE_CHARACTER_JUMP = 0.3,
    SCORE_TRANSPOSITION = 0.1,
    PENALTY_SKIPPED = 0.999,
    PENALTY_CASE_MISMATCH = 0.9999,
    PENALTY_DISTANCE_FROM_START = 0.9,
    PENALTY_NOT_COMPLETE = 0.99

  const IS_GAP_REGEXP = /[\\\/\-_+.#"@\[\(\{&]/,
    COUNT_GAPS_REGEXP = /[\\\/\-_+.#"@\[\(\{&]/g,
    IS_SPACE_REGEXP = /\s/,
    COUNT_SPACE_REGEXP = /\s/g

  function commandScore(string, abbreviation, lowerString, lowerAbbreviation, stringIndex=0, abbreviationIndex=0) {
    if (abbreviationIndex === abbreviation.length) {
      if (stringIndex === string.length) return SCORE_CONTINUE_MATCH
      return PENALTY_NOT_COMPLETE
    }

    let abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex)
    let index = lowerString.indexOf(abbreviationChar, stringIndex)
    let highScore = 0
    let score, transposedScore, wordBreaks, spaceBreaks

    while (index >= 0) {
      score = commandScore(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1);
      if (score > highScore) {
        if (index === stringIndex) {
          score *= SCORE_CONTINUE_MATCH
        } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {
          score *= SCORE_NON_SPACE_WORD_JUMP
          wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP)
          if (wordBreaks && stringIndex > 0) {
            score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length)
          }
        } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {
          score *= SCORE_SPACE_WORD_JUMP
          spaceBreaks = string.slice(stringIndex, index - 1).match(COUNT_SPACE_REGEXP)
          if (spaceBreaks && stringIndex > 0) {
            score *= Math.pow(PENALTY_SKIPPED, spaceBreaks.length)
          }
        } else {
          score *= SCORE_CHARACTER_JUMP
          if (stringIndex > 0) {
            score *= Math.pow(PENALTY_SKIPPED, index - stringIndex)
          }
        }

        if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex))
          score *= PENALTY_CASE_MISMATCH
      }

      if (SCORE_TRANSPOSITION > score && lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) && lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
        transposedScore = commandScore(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2)

        if (transposedScore * SCORE_TRANSPOSITION > score)
          score = transposedScore * SCORE_TRANSPOSITION
      }

      if (score > highScore)
        highScore = score
      index = lowerString.indexOf(abbreviationChar, index + 1)
    }

    return highScore;
  }

  export default {
    oncreate,
    data: () => ({input: '', selectedIndex: 0, nodes: []}),
    methods: {onKeyDown, setSelected, takeAction},
    helpers: {icon, altText},
    computed: {suggestions: ({input, nodes}) => suggestions(input, nodes)}
  }
</script>
